# 1. Java框架源码解读
Spring源码高级架构课程

MyBatis高级源码课程

RuoYi源码一套通


# 2. Java进阶扩展系列

## 2.1 设计模式精讲

### 2.1.1 为什么学习设计模式？

### 2.1.2 设计原则-单一原则？

### 2.1.3 开闭原则

### 2.1.4 里氏替换原则

### 2.1.5 接口隔离原则


### 2.1.6 依赖倒置原则

### 2.1.7 kiss原则


### 2.1.8 dry原则

### 2.1.9 迪米特法则

### 2.1.10 单例-概述

### 2.1.11 单例-懒汉饿汉双检锁

### 2.1.12 单例-内部类和枚举

### 2.1.13 单例-反射和序列化破坏

### 2.1.14 源码中的用法

### 2.1.15 单例-单例的问题

### 2.1.16 简单工厂

### 2.1.17 工厂方法设计模式

### 2.1.18 工厂-添加产品线

### 2.1.19 工厂-抽象工厂方法

### 2.1.20 工厂-应用场景和小结

### 2.1.21 创建者-基本原理

### 2.1.22 创建者-为什么使用

### 2.1.23 创建者-源码案例

### 2.1.24 原型-浅拷贝

### 2.1.25 原型-深拷贝

### 2.1.26 原型-应用场景

### 2.1.27 原型-源码中的用法

### 2.1.28 代理概述

### 2.1.29 静态代理

### 2.1.30 动态代理-jdk

### 2.1.31 动态代理-cjlib

### 2.1.32 动态代理-aop

### 2.1.33 动态代理的应用场景

### 2.1.34 装饰器设计模式

### 2.1.35 装饰器-io库


### 2.1.36 装饰器-mybatis缓存设计


### 2.1.37 桥接-jdbc中的应用

### 2.1.38 桥接-具体原理和实现

### 2.1.39 桥接-应用场景

### 2.1.40 适配器模式

### 2.1.41 适配器模式-典型的应用场景


RPC一套通

MySQL进阶

# 3. Java全系列面试题


## 3.1 Java基础精选面试题
### 3.1.1 String、StringBuffer、StringBuilder的区别


### 3.1.2 为什么重写equals方法的同时一定要重写hashCode方法？

### 3.1.3 ArrayList和LinkedList的区别


### 3.1.4 List和Set的区别？

### 3.1.5 ==和equals方法之间的区别

### 3.1.6 final关键字的作用是什么？

### 3.1.7 为什么局部内部类和匿名内部类只能访问局部final变量？

### 3.1.8 final、finally、finalize的区别？

### 3.1.9 重载和重写的区别？

### 3.1.10 接口和抽象类的区别？

### 3.1.11 深拷贝和浅拷贝？


### 3.1.12 JDK、JRE、JVM之间的区别？

### 3.1.13 看以下代码问答问题（一）

### 3.1.14 看以下代码问答问题（二）

### 3.1.15 str=abc与new String("abc")一样吗？


### 3.1.16 什么是面向对象？

### 3.1.17 泛型中extends与super的区别？
### 3.1.18 Java中的异常体系是怎样的？

### 3.1.19 throw和throws的区别？

### 3.1.20 常见的异常类有哪些？


### 3.1.21 什么是反射？

### 3.1.22 Math.round(-1.5)等于多少？

### 3.1.23 catch中return了finally还会执行吗？

### 3.1.24 Collection和Collections有什么区别？

### 3.1.25 如何实现数组和List之间的转换

### 3.1.26 队列和栈是什么？有什么区别？

### 3.1.27 说一下HashMap的实现原理？

### 3.1.28 HashMap的扩容机制原理？

### 3.1.29 ConcurrentHashMap的扩容机制？

### 3.1.30 说一下HashMap的Put方法


### 3.1.31 JDK1.7和1.8HashMap发生了什么变化（底层）

### 3.1.32 HashMap的长度为什么是2的N次幂？




## 3.2 Java王JVM入门到精通
### 3.2.1 Java最新面试题前言（2023）

### 3.2.2 类加载运行全过程

### 3.2.3 Java的四种类加载器详解

### 3.2.4 Java命令执行代码的流程

### 3.2.5 类加载（LoadClass）过程详解（一）
### 3.2.6 类加载（LoadClass）过程详解（二）

### 3.2.7 什么是类加载和反射？

### 3.2.8 什么是双亲委派机制

### 3.2.9 为什么要设计双亲委派机制？

### 3.2.10 JVM内存模型-程序计数器和虚拟机栈


### 3.2.11 队列和栈是什么以及有什么区别？

### 3.2.12 JVM内存模型-本地方法栈、堆、方法区

### 3.2.13 堆的新生代和老年代分析

### 3.2.14 Class常量池（字面量和符号引用）

### 3.2.15 运行时常量池

### 3.2.16 字符串常量池（一）

### 3.2.17 字符串常量池（二）

### 3.2.18 String常量池问题的几个笔试题
### 3.2.19 关于String是不可变的

### 3.2.20 八种基本类型的包装类和对象池

### 3.2.21 JVM内存参数设置和StackOver错误

### 3.2.22 反射的概念-到底什么是反射？

### 3.2.23 通过反射获取成员变量

### 3.2.24 通过反射获取成员方法

### 3.2.25 反射应用：解析自定义注解

### 3.2.26 内存分配机制-指针碰撞和空闲列表

### 3.2.27 内存分配机制-解决内存并发分配问题（TLAB）

### 3.2.28 内存分配机制-设置对象头


### 3.2.29 内存分配机制-对象分配内存总结


### 3.2.30 内存分配机制-对象栈上分配


### 3.2.31 内存分配机制-对象在Eden区分配


### 3.2.32 内存分配机制-大对象直接进入老年代


### 3.2.33 内存分配机制-长期存活的对象将进入老年代



### 3.2.34 内存分配机制-对象动态年龄判断


### 3.2.35 内存分配机制-老年代空间分配担保机制


### 3.2.36 内存分配机制-引用计数法


### 3.2.37 内存分配机制-可达性分析算法


### 3.2.38 强引用、软引用、弱引用、虚引用


### 3.2.39 finalize()方法最终判定对象是否存活

### 3.2.40 为什么finalize()方法不建议使用

### 3.2.41 如何判断一个类是无用的类？
### 3.2.42 Java会存在内存泄露吗？

### 3.2.43 垃圾收集算法（分代-复制-标记清除-标记整理）

### 3.2.44 垃圾收集器（Serial等l收集器）

### 3.2.45 CMS收集器

### 3.2.46 G1和ZGC收集器以及垃圾收集器总结

### 3.2.47 JVM调优实战-调优工具jmap
### 3.2.48 JVM调优实战-调优工具jinfo

### 3.2.49 JVM调优实战-用jstack查找死锁

### 3.2.50 解决生产环境CPU飙升100%





## 3.3 JVM面试题精讲
### 3.3.1 GC如何判断对象可以被回收？

### 3.3.2 Java的内存结构，堆分为哪几部分，默认年龄多大进入老年代

### 3.3.3 Java中有哪些类加载器
### 3.3.4 JDK1.7到JDK1.8虚拟机发生了什么变化？

### 3.3.5 JVM参数有哪些？

### 3.3.6 JVM有哪些垃圾回收器？

### 3.3.7 JVM中哪些可以作为gc？

### 3.3.8 JVM中哪些是线程共享区

### 3.3.9 你们项目如何排查JVM问题？

### 3.3.10 说说类加载器双亲委派模型

### 3.3.11 说一下JVM有哪些垃圾回收算法？

### 3.3.12 为什么要设计双亲委派机制？

### 3.3.13 一个对象从加载到JVM，再到被GC清除，都经历了什么过程？


## 3.4 一次学会SSM+SpringBoot面试题

### 3.4.1 JDK动态代理和CGLib动态代理实现原理

### 3.4.2 Mybatis存在哪些优点和缺点

### 3.4.3 Mybatis中的#{}和${}的区别是什么？

### 3.4.4 SpringBoot、SpringMVC和Spring有什么区别？

###  3.4.5 Spring是如何解决循坏依赖问题的？
### 3.4.6 SpringBoot中常用注解及其底层实现？

### 3.4.7 SpringMVC的底层工作流程

### 3.4.8 Spring的事务传播行为

### 3.4.9 Spring事务的实现方式和原理以及隔离级别？

### 3.4.10 Spring事务什么时候会失效？

### 3.4.11 Spring中Bean是线程安全的吗？

### 3.4.12 会不会自定义Starter大概实现步骤

### 3.4.13 解释下Spring支持的几种Bean的作用域

### 3.4.14 跨域请求是什么？有什么问题？怎么解决？


### 3.4.15 描述一下Spring Bean的生命周期

### 3.4.16 如何实现AOP，项目中哪些地方用到了AOP
### 3.4.17 什么是bean的自动装配，有哪些方式？

### 3.4.18 什么是SQL注入？

### 3.4.19 说说SpringBoot中的常用注解

### 3.4.20 谈谈你对AOP的理解

### 3.4.21 谈谈你对IOC的理解

### 3.4.22 @RestController和@Controller的区别？

### 3.4.23 ApplicationContext和BeanFactory有什么区别？







## 3.5 Java王MySQL面试篇



## 3.6 Redis面试篇

## 3.7 RocketMQ入门到精通【面试篇】

### 3.7.1 RocketMQ介绍以及版本关系说明

### 3.7.2 RocketMQ安装及启动NameServer
### 3.7.3 启动Broker

### 3.7.4 SpringBoot整合-发送同步、异步、单向消息

### 3.7.5 消费组消费同步、异步、单向消息

### 3.7.6 发送、消费顺序消息

### 3.7.7 广播消费和集群消费

### 3.7.8 发送延迟消息

### 3.7.9 发送批量消息

### 3.7.10 tag过滤消息

### 3.7.11 发送事务消息（一）

### 3.7.12 发送事务消息（二）

### 3.7.13 RocketMQ原理和概念
### 3.7.14 RocketMQ的消息存储模式

### 3.7.15 RocketMQ的刷盘机制

### 3.7.16 RocketMQ集群搭建（2主2从集群）一
### 3.7.17 RocketMQ集群搭建（2主2从集群）二

### 3.7.18 搭建RocketMQ管理控制台

### 3.7.19 RocketMQ的消息主从复制机制
### 3.7.20 RocketMQ的消息负载均衡方案

### 3.7.21 RocketMQ的消息重试机制

### 3.7.22 RocketMQ的死信队列机制

### 3.7.23 RocketMQ的消息幂等





## 3.8 Java并发面试题精讲

### 3.8.1 AQS对资源的共享方式？

### 3.8.2 CountDownLatch和Semaphore的区别底层原理

### 3.8.3 Java死锁如何避免

### 3.8.4 JVM对Java的原生锁做了哪些优化？

### 3.8.5 ReentranLock中tryLock()和lock()方法的区别？

### 3.8.6 ReentrantLock中的公平锁和非公平锁的底层实现？

### 3.8.7 sleep、wait、join、yield的区别？
### 3.8.8 Sychronized和ReentranLock的区别？

### 3.8.9 并发、并行、串行之间的区别？


### 3.8.10 并发编程三要素？

### 3.8.11 如果你提交任务时，线程池队列已满，这时会发生什么？


### 3.8.12 如何理解volatile关键字，它是如何保证可见性、有序性？


### 3.8.13 为什么不能直接调用run()方法启动线程


### 3.8.14 线程池的底层工作原理，fixedThreadPool的阻塞队列是什么？

### 3.8.15 线程池中线程复用原理

### 3.8.16 线程的生命周期？线程有几种状态


### 3.8.17 线程之间如何通讯？
### 3.8.18 自旋锁、偏向锁、轻量级锁、重量级锁是什么？

